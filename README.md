## Динамические Объекты и Точка! `dot`

Вкусные обжаренные в динамической типизации объекты. Прекрасно подойдут для самых требовательных SQL-запросов. Больше не нужно искать библиотеку для JSON, XML или REST API, для обработки данных, известных только на этапе выполнения. Данные нужного типа подтянутся для любого объекта, всё на булочке с кунжутом!

## Объекты с данными произвольного типа `dot::object`

Динамические Объекты и Точка могут содержать данные любых наследников класса. Большая часть встроенных типов уже готова к использованию, просто добавь воды:

`object count = 12; object truth = true; object weight = 76.5;`

Можно забрать данные из класса как простым преобразованием типа данных, так и специальным методом get_as<T>():

`int number = static_cast<int>(count); double value = weight.get_as<double>();`

Всеми любимый null теперь встроен в любой объект по умолчанию, если в него не переданы данные для инициализации:

`object nothing; if (nothing.is_null()) { ... } if (truth.is_not_null()) { ... }`

## Кошки и коробки `dot::box`

Маленькую начинку для объектов мы помещаем прямо в dot::object, во внутренний буфер. Такие объекты называются dot::box:

`box<long long> num = 100500LL; box<float> coef = 2.71828f;`

Можно использовать look() если вам только посмотреть, или touch() если хотите поменять объект:

`coef.touch() *= 1.1f; return num.look();`

Любой `box<type>` унаследован от промежуточного наследника `dot::box_based` данные в коробке называются кошками: `box<type>::cat` они также унаследованы от `dot::box_based::cat_based`, просто потому что кошкам уютно в коробках:

`object result = remote::call(argument); if (result.is<box_based>()) { ... }`

## Коровы и верёвки `dot::rope`

Большие данные, которые не лезут в коробку `box`, мы называем коровой `cow` и контролируем через верёвку `rope`. К одной корове можно привязать много верёвок, и пока вам только посмотреть, вам не нужна отдельная корова:

`rope<string> name = u8"Маруся"; rope<u32string> address = U"деревня Гадюкино";`

Так же как и `dot::box` все `dot::rope` унаследованны от промежуточного класса `dot::rope_based`. Все коровы `rope::cow` также унаследованы от промежуточного `rope_based::cow_based`. Для удобства использования метода is<T>():

`object result = request.response(); if (result.is<rope_based>()) { ... }`

## Краткое описание

Классы свободно поддерживают преобразования между типами даже в отсутствии RTTI. Сами проверяют что являются нужными инстансами нужных классов. Также можно проверить любой класс вручную.

Размер данных позволяет держать внутри объекта 2 int64 или 4 float, что удобно, например, для векторов и цветов. Такие данные поместятся в `dot::box` и не потребуют динамического выделения памяти.

Библиотека будет постепенно расти и точка!

### ... и да, кстати

Весь код должен поддерживать Unicode, а потому каждый файл с кодом в конце содержит специальную строку, которая должна выглядеть именно так:

// Здесь должен быть Unicode
